#!/usr/bin/python3
#
#    Copyright 2014 Hamza Abbad
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as published
#    by the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>
#
import sys
if not (sys.version_info.major>=3 and sys.version_info.minor >=2 ):
	print('FATAL ERROR : Python 3.2 or later version is needed to run BRET', file=sys.stderr)
	sys.exit(1) # (1) exit status is reserved for Python version error.
import argparse
import re
parser = argparse.ArgumentParser(description='Basic Regular Expressions Tester')
parser.add_argument('regexp', help='The regular expression pattern', metavar='RegExp')
tig = parser.add_mutually_exclusive_group(required=True)
tig.add_argument('-t', '--text', help='Text to be matched using the RegExp', metavar='Text')
tig.add_argument('-i', '--input', help='Get the text from a file', metavar='File')
parser.add_argument('-o', '--output', help='Write the results in a file', metavar='File')
parser.add_argument('-r', '--replace', help='Replace matched text', metavar='Replacement')
alg = parser.add_mutually_exclusive_group()
alg.add_argument('-a', '--all', action='store_true', help='Return all matches')
alg.add_argument('-l', '--limit', type=int, default='1', metavar='Limit')
parser.add_argument('-s', '--start', type=int, default='0', help='Set the starting position in the text', metavar='Position')
parser.add_argument('-e', '--end', type=int, help='Set the ending position in the text', metavar='Position')
parser.add_argument('-p', '--positions', action='store_true', help='Return the start and the end positions of the matches')
parser.add_argument('-q', '--quite', action='store_true', help='Return the results only')
parser.add_argument('-u', '--suppress-errors', action='store_true', help='Don\'t show error messages')
args = parser.parse_args()
if not args.text:
	try:
		args.input = open(args.input,'r')
	except OSError as e:
		print('ERROR : Couldn\'t read' , e.filename, ':', e.strerror)
		sys.exit(3) # (3) exit status is reserved for file errors.
	args.text = args.input.read(); args.input.close() # Send the file content to args.text variable in order to use it in the program.
if args.output:
	try:
		args.output = open(args.output,'w')
	except OSError as e:
		print('ERROR : Couldn\'t write' , e.filename, ':', e.strerror)
		sys.exit(3)
else: args.output = sys.stdout
n = len(args.text)
if not args.end or args.end > n: args.end = n # Set the default value of --end option on the last position.
if args.text[args.start:args.end]=='': args.start = args.end # Starting position mustn't be greater than the end.
try:
	rx = re.compile(args.regexp) # Create the RegExp and check if it is valid.
except re.error as e:
	if not args.suppress_errors: print('ERROR : invalid RegExp:', e.args[0], file=sys.stderr) # Print the error and exit with a non zero status.
	sys.exit(2); # (2) exit status is reserved for RegExp errors.
if not args.quite and not args.output: print('') # Just an empty line before the main output.
# Replacement part:
if args.replace:
	if not args.all:
		text, n = rx.subn(args.replace, args.text[args.start:args.end],args.limit)
	else:
		text, n = rx.subn(args.replace, args.text[args.start:args.end])
	text = args.text[:args.start]+text+args.text[args.end:] # Beginning + selected text + the end.
	if not args.quite: print(n,'replacement'+('s' if n>1 else ''), 'made:', file=args.output)
	print(text, file=args.output)
	sys.exit(0)
# Searching part:
NO_MATCH = 'WARNING : No match found' # Message to be displayed when no matches are found and --quite option is not specified.
if args.all:
	matches = list(rx.finditer(args.text, args.start, args.end)) # Create a list from an iterator of 'match' objects.
	n = len(matches) # Number of matches found.
	if not args.quite and n>0: print(n,'match'+('es' if n>1 else ''), 'found:', file=args.output) # Write 'matches' if n > 1.
	for x in matches:
	  print('- ' if not args.quite else '', x.group(), ((((' : match from ' if not args.quite else '(') + str(x.start()) + (' to ' if not args.quite else ',') + str(x.end())) if args.positions else '') + (')' if args.quite else '')), sep='', file=args.output)
	if not n :
		if not args.quite: print(NO_MATCH, file=sys.stderr)
		sys.exit(4) 
	sys.exit(0)
	if not n: # if there is no matches.
		if not args.quite: print(NO_MATCH, file=stderr)
		sys.exit(4) # (4) exit status is reserved for 'No match' warnings.
else:
	matches = [] # List of 'match' objects.
	start = args.start
	for i in range(args.limit): # Number of iterations = the limit of results requested.
		match = rx.search(args.text, start, args.end)
		if match : matches.append(match); start = match.end()
	n = len(matches)
	if not args.quite and n>0: print(n,'match'+('es' if n>1 else ''), 'found:', file=args.output) 
	for match in matches:
		print('- ' if not args.quite else '', match.group(), ((((' : match from ' if not args.quite else '(') + str(x.start()) + (' to ' if not args.quite else ',') + str(x.end())) if args.positions else '') + (')' if args.quite else '')), sep='', file=args.output)
	if not n:
		if not args.quite: print(NO_MATCH, file=sys.stderr)
		sys.exit(4)